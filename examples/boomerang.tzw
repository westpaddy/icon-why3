scope Preambles
  use export int.Int
  use export int.Abs
  use export int.EuclideanDivision
  use export list.List
  use export option.Option
  use export map.Map
  use export map.Const

  exception Insufficient_mutez
  exception Terminate

  type nat = int

  type mutez = int

  type address = int

  type key_hash = int

  type timestamp = int

  type ep =
    | Ep'0default

  type contract = (ep, int)

  type or 'a 'b = Left 'a | Right 'b

  type step = 
    { source: address;
      sender: address;
      self: address;
      amount: mutez
    }

  function mk_step (source : address) (sender : address) (self : address) (amount : mutez) : step =
    { source= source; 
      sender= sender;
      self= self;
      amount= amount }

  predicate step_wf (st : step) =
    st.amount >= 0

end

scope Unknown

  predicate pre (_c : ctx) = true

  predicate post (c : ctx) (c' : ctx) =
    c.boomerang_balance = c'.boomerang_balance

  scope Entrypoint

  predicate default unit

  end

end

scope Boomerang

  type storage = unit

  predicate pre (_c : ctx) = true

  predicate post (_st : step) (_gp : gparam) (c : ctx) (c' : ctx) = inv_post c c'

  let upper_ops = 1

  scope Spec

  predicate default (st : step) (_p : unit) (_s : storage) (ops : list operation) (_s' : storage) =
    (st.amount = 0 -> ops = Nil) /\
    (st.amount > 0 -> ops = Cons (Xfer (() : unit) st.amount (Contract st.sender)) Nil)

  end

end
